/* 
 * Square Connect API
 *
 * Client library for accessing the Square Connect APIs
 *
 * OpenAPI spec version: 2.0
 * Contact: developers@squareup.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;

namespace Square.Connect.Model
{
    /// <summary>
    /// A defined break template that sets an expectation for possible &#x60;Break&#x60;  instances on a &#x60;Shift&#x60;.
    /// </summary>
    [DataContract]
    public partial class BreakType :  IEquatable<BreakType>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BreakType" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected BreakType() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BreakType" /> class.
        /// </summary>
        /// <param name="Id">UUID for this object..</param>
        /// <param name="LocationId">The ID of the business location this type of break applies to. (required).</param>
        /// <param name="BreakName">A human-readable name for this type of break. Will be displayed to employees in Square products. (required).</param>
        /// <param name="ExpectedDuration">Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of this break. Precision below minutes is truncated. (required).</param>
        /// <param name="IsPaid">Whether this break counts towards time worked for compensation purposes. (required).</param>
        /// <param name="Version">Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If a value is not provided, Square&#39;s servers execute a \&quot;blind\&quot; write; potentially  overwriting another writer&#39;s data..</param>
        /// <param name="CreatedAt">A read-only timestamp in RFC 3339 format..</param>
        /// <param name="UpdatedAt">A read-only timestamp in RFC 3339 format..</param>
        public BreakType(string Id = default(string), string LocationId = default(string), string BreakName = default(string), string ExpectedDuration = default(string), bool? IsPaid = default(bool?), int? Version = default(int?), string CreatedAt = default(string), string UpdatedAt = default(string))
        {
            // to ensure "LocationId" is required (not null)
            if (LocationId == null)
            {
                throw new InvalidDataException("LocationId is a required property for BreakType and cannot be null");
            }
            else
            {
                this.LocationId = LocationId;
            }
            // to ensure "BreakName" is required (not null)
            if (BreakName == null)
            {
                throw new InvalidDataException("BreakName is a required property for BreakType and cannot be null");
            }
            else
            {
                this.BreakName = BreakName;
            }
            // to ensure "ExpectedDuration" is required (not null)
            if (ExpectedDuration == null)
            {
                throw new InvalidDataException("ExpectedDuration is a required property for BreakType and cannot be null");
            }
            else
            {
                this.ExpectedDuration = ExpectedDuration;
            }
            // to ensure "IsPaid" is required (not null)
            if (IsPaid == null)
            {
                throw new InvalidDataException("IsPaid is a required property for BreakType and cannot be null");
            }
            else
            {
                this.IsPaid = IsPaid;
            }
            this.Id = Id;
            this.Version = Version;
            this.CreatedAt = CreatedAt;
            this.UpdatedAt = UpdatedAt;
        }
        
        /// <summary>
        /// UUID for this object.
        /// </summary>
        /// <value>UUID for this object.</value>
        [DataMember(Name="id", EmitDefaultValue=false)]
        public string Id { get; set; }
        /// <summary>
        /// The ID of the business location this type of break applies to.
        /// </summary>
        /// <value>The ID of the business location this type of break applies to.</value>
        [DataMember(Name="location_id", EmitDefaultValue=false)]
        public string LocationId { get; set; }
        /// <summary>
        /// A human-readable name for this type of break. Will be displayed to employees in Square products.
        /// </summary>
        /// <value>A human-readable name for this type of break. Will be displayed to employees in Square products.</value>
        [DataMember(Name="break_name", EmitDefaultValue=false)]
        public string BreakName { get; set; }
        /// <summary>
        /// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of this break. Precision below minutes is truncated.
        /// </summary>
        /// <value>Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of this break. Precision below minutes is truncated.</value>
        [DataMember(Name="expected_duration", EmitDefaultValue=false)]
        public string ExpectedDuration { get; set; }
        /// <summary>
        /// Whether this break counts towards time worked for compensation purposes.
        /// </summary>
        /// <value>Whether this break counts towards time worked for compensation purposes.</value>
        [DataMember(Name="is_paid", EmitDefaultValue=false)]
        public bool? IsPaid { get; set; }
        /// <summary>
        /// Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If a value is not provided, Square&#39;s servers execute a \&quot;blind\&quot; write; potentially  overwriting another writer&#39;s data.
        /// </summary>
        /// <value>Used for resolving concurrency issues; request will fail if version provided does not match server version at time of request. If a value is not provided, Square&#39;s servers execute a \&quot;blind\&quot; write; potentially  overwriting another writer&#39;s data.</value>
        [DataMember(Name="version", EmitDefaultValue=false)]
        public int? Version { get; set; }
        /// <summary>
        /// A read-only timestamp in RFC 3339 format.
        /// </summary>
        /// <value>A read-only timestamp in RFC 3339 format.</value>
        [DataMember(Name="created_at", EmitDefaultValue=false)]
        public string CreatedAt { get; set; }
        /// <summary>
        /// A read-only timestamp in RFC 3339 format.
        /// </summary>
        /// <value>A read-only timestamp in RFC 3339 format.</value>
        [DataMember(Name="updated_at", EmitDefaultValue=false)]
        public string UpdatedAt { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class BreakType {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  LocationId: ").Append(LocationId).Append("\n");
            sb.Append("  BreakName: ").Append(BreakName).Append("\n");
            sb.Append("  ExpectedDuration: ").Append(ExpectedDuration).Append("\n");
            sb.Append("  IsPaid: ").Append(IsPaid).Append("\n");
            sb.Append("  Version: ").Append(Version).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as BreakType);
        }

        /// <summary>
        /// Returns true if BreakType instances are equal
        /// </summary>
        /// <param name="other">Instance of BreakType to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BreakType other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.Id == other.Id ||
                    this.Id != null &&
                    this.Id.Equals(other.Id)
                ) && 
                (
                    this.LocationId == other.LocationId ||
                    this.LocationId != null &&
                    this.LocationId.Equals(other.LocationId)
                ) && 
                (
                    this.BreakName == other.BreakName ||
                    this.BreakName != null &&
                    this.BreakName.Equals(other.BreakName)
                ) && 
                (
                    this.ExpectedDuration == other.ExpectedDuration ||
                    this.ExpectedDuration != null &&
                    this.ExpectedDuration.Equals(other.ExpectedDuration)
                ) && 
                (
                    this.IsPaid == other.IsPaid ||
                    this.IsPaid != null &&
                    this.IsPaid.Equals(other.IsPaid)
                ) && 
                (
                    this.Version == other.Version ||
                    this.Version != null &&
                    this.Version.Equals(other.Version)
                ) && 
                (
                    this.CreatedAt == other.CreatedAt ||
                    this.CreatedAt != null &&
                    this.CreatedAt.Equals(other.CreatedAt)
                ) && 
                (
                    this.UpdatedAt == other.UpdatedAt ||
                    this.UpdatedAt != null &&
                    this.UpdatedAt.Equals(other.UpdatedAt)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.Id != null)
                    hash = hash * 59 + this.Id.GetHashCode();
                if (this.LocationId != null)
                    hash = hash * 59 + this.LocationId.GetHashCode();
                if (this.BreakName != null)
                    hash = hash * 59 + this.BreakName.GetHashCode();
                if (this.ExpectedDuration != null)
                    hash = hash * 59 + this.ExpectedDuration.GetHashCode();
                if (this.IsPaid != null)
                    hash = hash * 59 + this.IsPaid.GetHashCode();
                if (this.Version != null)
                    hash = hash * 59 + this.Version.GetHashCode();
                if (this.CreatedAt != null)
                    hash = hash * 59 + this.CreatedAt.GetHashCode();
                if (this.UpdatedAt != null)
                    hash = hash * 59 + this.UpdatedAt.GetHashCode();
                return hash;
            }
        }

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        { 
            // Id (string) maxLength
            if(this.Id != null && this.Id.Length > 255)
            {
                yield return new ValidationResult("Invalid value for Id, length must be less than 255.", new [] { "Id" });
            }

            // LocationId (string) minLength
            if(this.LocationId != null && this.LocationId.Length < 1)
            {
                yield return new ValidationResult("Invalid value for LocationId, length must be greater than 1.", new [] { "LocationId" });
            }

            // BreakName (string) minLength
            if(this.BreakName != null && this.BreakName.Length < 1)
            {
                yield return new ValidationResult("Invalid value for BreakName, length must be greater than 1.", new [] { "BreakName" });
            }

            // ExpectedDuration (string) minLength
            if(this.ExpectedDuration != null && this.ExpectedDuration.Length < 1)
            {
                yield return new ValidationResult("Invalid value for ExpectedDuration, length must be greater than 1.", new [] { "ExpectedDuration" });
            }

            yield break;
        }
    }

}
